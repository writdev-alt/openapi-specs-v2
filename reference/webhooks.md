# Webhooks

Webhooks allow you to receive real-time notifications about events in your WRPay account. When a payment is received, a transaction status changes, or other important events occur, WRPay will send an HTTP POST request to your configured webhook URL.

## Overview

Webhooks are HTTP callbacks that notify your application when specific events occur. Instead of polling the API for updates, you can configure webhooks to receive instant notifications.

### Benefits

- **Real-time updates**: Receive notifications immediately when events occur
- **Efficient**: No need to poll the API repeatedly
- **Reliable**: Automatic retry mechanism for failed deliveries
- **Secure**: Signature verification ensures authenticity

## Configuration

Configure your webhook URL in the merchant dashboard under **Settings > Webhooks**. You can set different webhook URLs for different event types.

### Webhook URL Requirements

- Must be publicly accessible (HTTPS recommended)
- Must respond with HTTP 200 status code within 10 seconds
- Should return a JSON response (even if empty: `{}`)

## Webhook Events

### Payment Events

#### `receive_payment`

Triggered when a payment status changes to `pending` or `completed`. This webhook is only sent for these two statuses.

**Event Type**: `receive_payment`

**Supported Statuses**: `pending`, `completed`

**Payload Structure**:

```json
{
  "event": "receive_payment",
  "data": {
    "trx_id": "TRX-2025.11.12-3QS4LURBQ6",
    "trx_reference": "ILONAPAY_69146275622d7",
    "rrn": "1ittl5s63288",
    "amount": "2000.00",
    "currency_code": "IDR",
    "description": null,
    "customer_name": null,
    "customer_email": null,
    "customer_phone": null,
    "merchant_id": 22,
    "merchant_name": "KPK79",
    "payment_method": "QRIS"
  },
  "message": "Receive Payment via QRIS",
  "status": "completed",
  "timestamp": 1762943651
}
```

**Note**: This webhook is only sent when the payment status is `pending` or `completed`. For other statuses, monitor transactions using the [Check Transaction Status](../paths/transactions.yaml) endpoint.

**Data Fields**:

| Field | Type | Description |
|-------|------|-------------|
| `trx_id` | string | Unique transaction identifier generated by the system |
| `trx_reference` | string | Merchant's transaction reference (if provided) |
| `rrn` | string | Retrieval Reference Number from the payment gateway |
| `amount` | string | Payment amount as a decimal string |
| `currency_code` | string | Currency code (e.g., "IDR") |
| `description` | string \| null | Customer-facing description |
| `customer_name` | string \| null | Customer's full name |
| `customer_email` | string \| null | Customer's email address |
| `customer_phone` | string \| null | Customer's phone number |
| `merchant_id` | integer | Your merchant ID |
| `merchant_name` | string | Your merchant name |
| `payment_method` | string | Payment method used (e.g., "QRIS") |

**Top-Level Fields**:

| Field | Type | Description |
|-------|------|-------------|
| `event` | string | Event type identifier |
| `data` | object | Event-specific data payload |
| `message` | string | Human-readable message describing the event |
| `status` | string | Transaction status (e.g., "completed", "pending", "failed") |
| `timestamp` | integer | Unix timestamp when the event occurred |

#### `withdrawal`

Triggered when a withdrawal transaction status changes (created, processing, completed, failed, etc.).

**Event Type**: `withdrawal`

**Payload Structure**:

```json
{
  "event": "withdrawal",
  "data": {
    "trx_id": "TRX-2025.01.15-ABC123XYZ",
    "trx_reference": "WD-2025-0001",
    "amount": "250000.00",
    "net_amount": "245000.00",
    "payable_amount": "245000.00",
    "currency_code": "IDR",
    "status": "completed",
    "description": "Withdrawal to Bank BCA",
    "merchant_id": 22,
    "merchant_name": "KPK79",
    "withdrawal_method": "Bank Transfer",
    "account_name": "Bank BCA",
    "account_holder_name": "Budi Santoso",
    "account_bank_name": "Bank Central Asia",
    "account_number": "1234567890",
    "account_bank_code": "014",
    "trx_fee": "5000.00",
    "remarks": "Withdrawal processed successfully",
    "environment": "production",
    "is_sandbox": false
  },
  "message": "Withdrawal completed successfully",
  "timestamp": 1762943651
}
```

**Data Fields**:

| Field | Type | Description |
|-------|------|-------------|
| `trx_id` | string | Unique transaction identifier generated by the system |
| `trx_reference` | string \| null | Merchant's transaction reference (if provided) |
| `amount` | string | Original withdrawal amount as a decimal string |
| `net_amount` | string | Net amount after fees as a decimal string |
| `payable_amount` | string | Final amount to be paid out as a decimal string |
| `currency_code` | string | Currency code (e.g., "IDR") |
| `status` | string | Withdrawal status (e.g., "pending", "completed", "failed") |
| `description` | string \| null | Description of the withdrawal |
| `merchant_id` | integer | Your merchant ID |
| `merchant_name` | string \| null | Your merchant business name |
| `withdrawal_method` | string | Withdrawal method used (e.g., "Bank Transfer") |
| `account_name` | string \| null | Name of the withdrawal account |
| `account_holder_name` | string \| null | Account holder's full name |
| `account_bank_name` | string \| null | Bank name for the withdrawal account |
| `account_number` | string \| null | Account number for withdrawal |
| `account_bank_code` | string \| null | Bank code (e.g., "014" for BCA) |
| `trx_fee` | string | Transaction fee charged as a decimal string |
| `remarks` | string \| null | Additional remarks or notes |
| `environment` | string | Environment where the transaction occurred ("production" or "sandbox") |
| `is_sandbox` | boolean | Whether the transaction is in sandbox mode |

**Top-Level Fields**:

| Field | Type | Description |
|-------|------|-------------|
| `event` | string | Event type identifier ("withdrawal") |
| `data` | object | Withdrawal-specific data payload |
| `message` | string | Human-readable message describing the event |
| `timestamp` | integer | Unix timestamp when the event occurred |

## Webhook Payload Structure

All webhook payloads follow this general structure:

```json
{
  "event": "event_type",
  "data": {
    // Event-specific data
  },
  "message": "Human-readable message",
  "status": "transaction_status",
  "timestamp": 1234567890
}
```

### Common Status Values

- `pending` - Transaction is pending
- `completed` - Transaction completed successfully
- `failed` - Transaction failed
- `canceled` - Transaction was canceled
- `expired` - Transaction expired

### Withdrawal Events

#### `withdrawal`

Triggered when a withdrawal transaction status changes (created, processing, completed, failed, etc.).

See [Transaction Statuses](./transaction-statuses.md) for complete list.

## Security

### Signature Verification

Each webhook request includes a signature header that you can use to verify the request authenticity. The signature is generated using HMAC-SHA256 with your webhook secret.

**Headers**:

- `x-signature`: HMAC-SHA256 signature of the request body
- `x-timestamp`: Unix timestamp of the request (optional, if provided)

**Verification Process**:

1. Get the signature from the `x-signature` header
2. Compute HMAC-SHA256 of the request body using your webhook secret
3. Compare the computed signature with the `x-signature` header value

**Example (Node.js)**:

```javascript
const crypto = require('crypto');

function verifyWebhookSignature(signature, body, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(body)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

// Usage
const signature = req.headers['x-signature'];
const body = JSON.stringify(req.body);

if (!verifyWebhookSignature(signature, body, WEBHOOK_SECRET)) {
  return res.status(401).json({ error: 'Invalid signature' });
}
```

**Example (Python)**:

```python
import hmac
import hashlib

def verify_webhook_signature(signature, body, secret):
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        body.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected_signature)

# Usage
signature = request.headers.get('x-signature')
body = json.dumps(request.json)

if not verify_webhook_signature(signature, body, WEBHOOK_SECRET):
    return jsonify({'error': 'Invalid signature'}), 401
```

## Handling Webhooks

### Best Practices

1. **Respond Quickly**: Return HTTP 200 within 10 seconds
2. **Idempotency**: Use `trx_id` to prevent duplicate processing
3. **Logging**: Log all webhook requests for debugging
4. **Error Handling**: Handle errors gracefully and return appropriate status codes
5. **Verification**: Always verify webhook signatures

### Response Format

Your webhook endpoint should return a JSON response:

**Success**:

```json
{
  "received": true,
  "message": "Webhook processed successfully"
}
```

**Error** (optional, for logging):

```json
{
  "received": false,
  "error": "Error message"
}
```

### Idempotency

Use the `trx_id` field to ensure you don't process the same event twice:

```javascript
// Example: Check if transaction already processed
const existingTransaction = await db.transactions.findOne({
  trx_id: webhook.data.trx_id
});

if (existingTransaction) {
  // Already processed, return success
  return res.json({ received: true, message: 'Already processed' });
}

// Process new transaction
await processPayment(webhook.data);
```

## Retry Mechanism

If your webhook endpoint doesn't respond with HTTP 200 within 10 seconds, or returns an error status code, WRPay will retry the delivery:

- **Retry Schedule**: Exponential backoff
  - 1st retry: 1 minute
  - 2nd retry: 5 minutes
  - 3rd retry: 15 minutes
  - 4th retry: 1 hour
  - 5th retry: 6 hours
  - Maximum: 24 hours after initial attempt

- **Total Attempts**: Up to 6 attempts over 24 hours
- **Final Status**: If all retries fail, the webhook is marked as failed

## Testing Webhooks

### Using ngrok (Local Development)

1. Install ngrok: `npm install -g ngrok`
2. Start your local server
3. Expose it: `ngrok http 3000`
4. Use the ngrok URL as your webhook URL in the dashboard

### Webhook Testing Endpoint

You can use the [Resend Callback endpoint](../paths/transactions.yaml) to manually trigger a webhook for testing:

```bash
POST /api/v2/resend-callback/{trx_id}
```

## Example Implementation

### Node.js/Express

```javascript
const express = require('express');
const crypto = require('crypto');
const app = express();

app.use(express.json({ verify: (req, res, buf) => {
  req.rawBody = buf.toString();
}}));

app.post('/webhook', async (req, res) => {
    try {
    // Verify signature
    const signature = req.headers['x-signature'];
    
    if (!verifySignature(signature, req.rawBody, process.env.WEBHOOK_SECRET)) {
      return res.status(401).json({ error: 'Invalid signature' });
    }
    
    const { event, data, status, timestamp: eventTimestamp } = req.body;
    
    // Handle different event types
    switch (event) {
      case 'receive_payment':
        await handlePaymentReceived(data);
        break;
      case 'withdrawal':
        await handleWithdrawal(data);
        break;
      default:
        console.log('Unknown event type:', event);
    }
    
    // Return success response
    res.json({ received: true, message: 'Webhook processed' });
    
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

async function handlePaymentReceived(data) {
  // Process payment
  console.log('Payment received:', data.trx_id);
  // Update your database, send notifications, etc.
}

async function handleWithdrawal(data) {
  // Process withdrawal
  console.log('Withdrawal event:', data.trx_id, 'Status:', data.status);
  // Update your database, send notifications, etc.
}

function verifySignature(signature, body, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(body)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

app.listen(3000, () => {
  console.log('Webhook server listening on port 3000');
});
```

### Python/Flask

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import os

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        # Verify signature
        signature = request.headers.get('x-signature')
        body = request.get_data(as_text=True)
        
        if not verify_signature(signature, body, os.environ['WEBHOOK_SECRET']):
            return jsonify({'error': 'Invalid signature'}), 401
        
        data = request.json
        event = data.get('event')
        
        # Handle different event types
        if event == 'receive_payment':
            handle_payment_received(data['data'])
        elif event == 'withdrawal':
            handle_withdrawal(data['data'])
        
        return jsonify({'received': True, 'message': 'Webhook processed'})
        
    except Exception as e:
        print(f'Webhook error: {e}')
        return jsonify({'error': 'Internal server error'}), 500

def handle_payment_received(data):
    # Process payment
    print(f"Payment received: {data['trx_id']}")
    # Update your database, send notifications, etc.

def handle_withdrawal(data):
    # Process withdrawal
    print(f"Withdrawal event: {data['trx_id']}, Status: {data['status']}")
    # Update your database, send notifications, etc.

def verify_signature(signature, body, secret):
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        body.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected_signature)

if __name__ == '__main__':
    app.run(port=3000)
```

## Troubleshooting

### Common Issues

**Webhook not received**:
- Check webhook URL is publicly accessible
- Verify URL is correctly configured in dashboard
- Check server logs for incoming requests
- Ensure firewall/security groups allow incoming connections

**Signature verification fails**:
- Verify webhook secret matches dashboard configuration
- Ensure you're using the raw request body (before JSON parsing)
- Check that you're reading the `x-signature` header correctly (case-insensitive)

**Timeout errors**:
- Optimize webhook handler to respond quickly
- Move heavy processing to background jobs
- Return HTTP 200 immediately, process asynchronously

**Duplicate events**:
- Implement idempotency checks using `trx_id`
- Store processed transaction IDs in database
- Check for existing records before processing

## Related Documentation

- [Transaction Statuses](./transaction-statuses.md)
- [Common Responses](./common-responses.md)
- [Error Codes](./error-codes.md)
- [Resend Callback](../paths/transactions.yaml)

